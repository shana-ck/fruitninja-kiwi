import { readCar as createCarIterator } from "@atcute/car";
import { decode, decodeFirst, fromBytes, toCIDLink } from "@atcute/cbor";
import { EventEmitter } from "node:events";
import * as WS from "ws";
export class Firehose extends EventEmitter {
    /** The relay to connect to. */
    relay;
    /** WebSocket connection to the relay. */
    ws;
    /** The current cursor. */
    cursor = "";
    autoReconnect;
    reconnectTimeout;
    /**
     * Creates a new Firehose instance.
     * @param options Optional configuration.
     */
    constructor(options = {}) {
        super();
        this.relay = options.relay ?? "wss://bsky.network";
        this.cursor = options.cursor ?? "";
        this.autoReconnect = options.autoReconnect ?? true;
    }
    /**
     * Opens a WebSocket connection to the relay.
     */
    start() {
        const cursorQueryParameter = this.cursor ? `?cursor=${this.cursor}` : "";
        this.ws = new WS.WebSocket(`${this.relay}/xrpc/com.atproto.sync.subscribeRepos${cursorQueryParameter}`);
        this.ws.on("open", () => {
            this.emit("open");
        });
        this.ws.on("message", (data) => {
            try {
                const message = this.parseMessage(data);
                if ("seq" in message && message.seq && !isNaN(message.seq)) {
                    this.cursor = `${message.seq}`;
                }
                switch (message.$type) {
                    case "com.atproto.sync.subscribeRepos#handle":
                        this.emit("handle", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#tombstone":
                        this.emit("tombstone", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#migrate":
                        this.emit("migrate", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#identity":
                        this.emit("identity", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#info":
                        this.emit("info", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#commit":
                        this.emit("commit", message);
                        break;
                    default:
                        this.emit("unknown", message);
                        break;
                }
            }
            catch (error) {
                this.emit("error", { cursor: this.cursor, error });
            }
            finally {
                if (this.autoReconnect)
                    this.preventReconnect();
            }
        });
        this.ws.on("close", () => {
            this.emit("close", this.cursor);
        });
        this.ws.on("error", (error) => {
            this.emit("websocketError", { cursor: this.cursor, error });
        });
    }
    /**
     * Closes the WebSocket connection.
     */
    close() {
        this.ws?.close();
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    parseMessage(data) {
        let buffer;
        if (data instanceof Buffer) {
            buffer = data;
        }
        else if (data instanceof ArrayBuffer) {
            buffer = Buffer.from(data);
        }
        else if (Array.isArray(data)) {
            buffer = Buffer.concat(data);
        }
        else {
            throw new Error("Unknown message contents: " + data);
        }
        const [header, remainder] = decodeFirst(buffer);
        const [body, remainder2] = decodeFirst(remainder);
        if (remainder2.length > 0) {
            throw new Error("Excess bytes in message");
        }
        const { t, op } = parseHeader(header);
        if (op === -1)
            throw new Error(`Error: ${body.message}\nError code: ${body.error}`);
        if (t === "#commit") {
            const commit = body;
            // A commit can contain no changes
            if (!("blocks" in commit) || !(commit.blocks.$bytes.length)) {
                return {
                    $type: "com.atproto.sync.subscribeRepos#commit",
                    ...commit,
                    blocks: new Uint8Array(),
                    ops: [],
                };
            }
            const blocks = fromBytes(commit.blocks);
            const car = readCar(blocks);
            const ops = commit.ops.map((op) => {
                const action = op.action;
                if (action === "create" || action === "update") {
                    if (!op.cid)
                        return;
                    const record = car.get(op.cid.$link);
                    if (!record)
                        return;
                    return { action, path: op.path, cid: op.cid.$link, record };
                }
                else if (action === "delete") {
                    return { action, path: op.path };
                }
                else {
                    throw new Error(`Unknown action: ${action}`);
                }
            }).filter((op) => !!op);
            return {
                $type: "com.atproto.sync.subscribeRepos#commit",
                ...commit,
                blocks,
                ops,
            };
        }
        return { $type: `com.atproto.sync.subscribeRepos${t}`, ...body };
    }
    preventReconnect() {
        if (this.reconnectTimeout)
            clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = setTimeout(() => {
            this.reconnect();
        }, 5_000);
    }
    reconnect() {
        this.ws?.removeAllListeners();
        this.ws?.terminate();
        this.start();
        this.emit("reconnect");
    }
}
function parseHeader(header) {
    if (!header || typeof header !== "object" || !header.t || typeof header.t !== "string"
        || !header.op || typeof header.op !== "number")
        throw new Error("Invalid header received");
    return { t: header.t, op: header.op };
}
function readCar(buffer) {
    const records = new Map();
    for (const { cid, bytes } of createCarIterator(buffer).iterate()) {
        records.set(toCIDLink(cid).$link, decode(bytes));
    }
    return records;
}
