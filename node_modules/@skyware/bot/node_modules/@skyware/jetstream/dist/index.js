import "@atcute/bluesky/lexicons";
import { EventEmitter } from "node:events";
import { WebSocket } from "partysocket";
/**
 * The Jetstream client.
 */
export class Jetstream extends EventEmitter {
    /** WebSocket connection to the server. */
    ws;
    /** The full connection URL. */
    url;
    /** The current cursor. */
    cursor;
    /** The WebSocket implementation to use. */
    wsImpl;
    constructor(options) {
        super();
        options ??= {};
        if (options.ws)
            this.wsImpl = options.ws;
        if (typeof globalThis.WebSocket === "undefined" && !this.wsImpl) {
            throw new Error(`No WebSocket implementation was found in your environment. You must provide an implementation as the \`ws\` option.

For example, in a Node.js environment, \`npm install ws\` and then:
import { Jetstream } from "@skyware/jetstream";
import WebSocket from "ws";

const jetstream = new Jetstream({
	ws: WebSocket,
});`);
        }
        this.url = new URL(options.endpoint ?? "wss://jetstream1.us-east.bsky.network/subscribe");
        options.wantedCollections?.forEach((collection) => {
            this.url.searchParams.append("wantedCollections", collection);
        });
        options.wantedDids?.forEach((did) => {
            this.url.searchParams.append("wantedDids", did);
        });
        if (options.cursor)
            this.cursor = options.cursor;
    }
    /**
     * Opens a WebSocket connection to the server.
     */
    start() {
        this.ws = new WebSocket(() => this.createUrl(), null, { WebSocket: this.wsImpl });
        this.ws.onopen = () => this.emit("open");
        this.ws.onclose = () => this.emit("close");
        this.ws.onerror = ({ error }) => this.emit("error", error, this.cursor);
        this.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.time_us > (this.cursor ?? 0))
                    this.cursor = data.time_us;
                switch (data.type) {
                    case EventType.Commit:
                        if (!data.commit?.collection || !data.commit.rkey || !data.commit.rev) {
                            return;
                        }
                        if (data.commit.type === CommitType.Create && !data.commit.record)
                            return;
                        this.emit("commit", data);
                        // @ts-expect-error â€“ We know we can use collection name as an event.
                        this.emit(data.commit.collection, data);
                        break;
                    case EventType.Account:
                        if (!data.account?.did)
                            return;
                        this.emit("account", data);
                        break;
                    case EventType.Identity:
                        if (!data.identity?.did)
                            return;
                        this.emit("identity", data);
                        break;
                }
            }
            catch (e) {
                this.emit("error", e instanceof Error ? e : new Error(e), this.cursor);
            }
        };
    }
    /**
     * Closes the WebSocket connection.
     */
    close() {
        this.ws?.close();
    }
    /**
     * Listen for records created in a specific collection.
     * @param collection The name of the collection to listen for.
     * @param listener A callback function that receives the commit event.
     */
    onCreate(collection, listener) {
        this.on(collection, ({ commit, ...event }) => {
            if (commit.type === CommitType.Create)
                listener({ commit, ...event });
        });
    }
    /**
     * Listen for records updated in a specific collection.
     * @param collection The name of the collection to listen for.
     * @param listener A callback function that receives the commit event.
     */
    onUpdate(collection, listener) {
        this.on(collection, ({ commit, ...event }) => {
            if (commit.type === CommitType.Update)
                listener({ commit, ...event });
        });
    }
    /**
     * Listen for records deleted in a specific collection.
     * @param collection The name of the collection to listen for.
     * @param listener A callback function that receives the commit event.
     */
    onDelete(collection, listener) {
        this.on(collection, ({ commit, ...event }) => {
            if (commit.type === CommitType.Delete)
                listener({ commit, ...event });
        });
    }
    createUrl() {
        if (this.cursor)
            this.url.searchParams.set("cursor", this.cursor.toString());
        return this.url.toString();
    }
    /**
     * @param event The event to listen for.
     * @param listener The callback function, called when the event is emitted.
     */
    on(event, listener) {
        return super.on(event, listener);
    }
}
/**
 * The types of events that are emitted by {@link Jetstream}.
 * @enum
 */
export const EventType = {
    /** A new commit. */
    Commit: "com",
    /** An account's status was updated. */
    Account: "acc",
    /** An account's identity was updated. */
    Identity: "id",
};
/**
 * The types of commits that can be received.
 * @enum
 */
export const CommitType = {
    /** A record was created. */
    Create: "c",
    /** A record was updated. */
    Update: "u",
    /** A record was deleted. */
    Delete: "d",
};
