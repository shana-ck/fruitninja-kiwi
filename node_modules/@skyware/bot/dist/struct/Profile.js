import { asDid } from "../util/lexicon.js";
/**
 * A Bluesky user profile.
 */
export class Profile {
    bot;
    /** The user's DID. */
    did;
    /** The user's handle. */
    handle;
    /** The user's display name. */
    displayName;
    /** The user's profile description . */
    description;
    /** The user's avatar URL. */
    avatar;
    /** The user's banner URL. */
    banner;
    /** The number of followers the user has. */
    followerCount;
    /** The number of users the user is following. */
    followingCount;
    /** The number of posts the user has made. */
    postsCount;
    /** Labels on the user's profile. */
    labels;
    /** The time when the user's profile was indexed by the AppView. */
    indexedAt;
    /**
     * The AT URI of the follow relationship between the bot and the user.
     * Undefined if the bot is not following the user.
     */
    followUri;
    /**
     * The AT URI of the follow relationship between the bot and the user.
     * Undefined if the user is not following the bot.
     */
    followedByUri;
    /** Whether the user is muted by the bot. */
    isMuted;
    /**
     * The AT URI of the block relationship between the bot and the user.
     * Undefined if the user is not blocking the bot.
     */
    blockUri;
    /** Whether the bot is blocked by the user. */
    blockedBy;
    /** Whether the user account is a labeler. */
    isLabeler;
    /** The user's preference for who can initiate a chat conversation. */
    incomingChatPreference;
    /** The DM conversation between the bot and this user. */
    conversation;
    /** Whether the bot is following the user. */
    get isFollowing() {
        return this.followUri != undefined;
    }
    /** Whether the user is following the bot */
    get followedBy() {
        return this.followedByUri != undefined;
    }
    /** Whether the bot is blocking the user */
    get isBlocking() {
        return this.blockUri != undefined;
    }
    /** Whether the user is being followed and is following the bot */
    get isMutual() {
        return this.isFollowing && this.followedBy;
    }
    /**
     * @param data Profile data.
     * @param bot The active Bot instance.
     */
    constructor(
    // dprint-ignore
    { did, handle, displayName, description, avatar, banner, followerCount, followingCount, postsCount, labels, indexedAt, followUri, followedByUri, isMuted, blockUri, isBlockedBy, isLabeler, incomingChatPreference }, bot) {
        this.bot = bot;
        this.did = asDid(did);
        this.handle = handle;
        if (displayName)
            this.displayName = displayName;
        if (description)
            this.description = description;
        if (avatar)
            this.avatar = avatar;
        if (banner)
            this.banner = banner;
        if (followerCount != undefined)
            this.followerCount = followerCount;
        if (followingCount != undefined)
            this.followingCount = followingCount;
        if (postsCount != undefined)
            this.postsCount = postsCount;
        this.labels = labels ?? [];
        if (indexedAt)
            this.indexedAt = indexedAt;
        if (followUri != undefined)
            this.followUri = followUri;
        if (followedByUri != undefined)
            this.followedByUri = followedByUri;
        if (isMuted != undefined)
            this.isMuted = isMuted;
        if (blockUri != undefined)
            this.blockUri = blockUri;
        if (isBlockedBy != undefined)
            this.blockedBy = isBlockedBy;
        if (isLabeler != undefined)
            this.isLabeler = isLabeler;
        if (incomingChatPreference)
            this.incomingChatPreference = incomingChatPreference;
    }
    /**
     * Follow the user.
     * @returns The AT URI of the follow relationship.
     */
    async follow() {
        return this.followUri = (await this.bot.follow(this.did)).uri;
    }
    /**
     * Unfollow the user.
     */
    async unfollow() {
        return this.bot.unfollow(this.did);
    }
    /**
     * Mute the user.
     */
    async mute() {
        return this.bot.mute(this.did);
    }
    /**
     * Unmute the user.
     */
    async unmute() {
        return this.bot.unmute(this.did);
    }
    /**
     * Block the user.
     * @returns The AT URI of the block relationship.
     */
    async block() {
        return this.blockUri = (await this.bot.block(this.did)).uri;
    }
    /**
     * Unblock the user.
     */
    async unblock() {
        return this.bot.unblock(this.did);
    }
    /**
     * Fetch the user's posts (up to 100 at a time, default 100).
     * @param options Optional configuration.
     * @returns The user's posts and a cursor for pagination.
     */
    async getPosts(options = {}) {
        return this.bot.getUserPosts(this.did, { limit: 100, ...options });
    }
    /**
     * Fetch the user's liked posts (up to 100 at a time, default 100).
     * @param options Optional configuration.
     * @returns The user's liked posts and a cursor for pagination.
     */
    async getLikedPosts(options = {}) {
        return this.bot.getUserLikes(this.did, { limit: 100, ...options });
    }
    /**
     * Fetch the user's lists (up to 100 at a time, default 100).
     * @param options Optional configuration.
     * @returns The user's lists and a cursor for pagination.
     */
    async getLists(options = {}) {
        return this.bot.getUserLists(this.did, { limit: 100, ...options });
    }
    /**
     * Fetch the user's starter packs (up to 25 at a time, default 25).
     * @returns The user's starter packs.
     */
    async getStarterPacks(options = {}) {
        return this.bot.getUserStarterPacks(this.did, options);
    }
    /**
     * Fetch the labeler associated with the user, if there is any.
     * Check the {@link isLabeler} property before calling this method!
     * @returns The labeler associated with the user.
     */
    async getLabeler() {
        return this.bot.getLabeler(this.did);
    }
    /**
     * Get the DM conversation between the bot and this user.
     */
    async getConversation() {
        return this.conversation
            || (this.conversation = await this.bot.getConversationForMembers([this.did]));
    }
    /**
     * Fetch the message history between the bot and this user.
     * @param cursor The cursor to begin fetching from.
     * @returns An array of messages and a cursor for pagination.
     */
    async getMessages(cursor) {
        const convo = this.conversation ?? await this.getConversation();
        return convo.getMessages(cursor);
    }
    /**
     * Send the user a direct message.
     * @param payload The message to send.
     */
    async sendMessage(payload) {
        const convo = this.conversation ?? await this.getConversation();
        return convo.sendMessage(payload);
    }
    /**
     * Apply labels to the user's account. Note that this will label the user's profile and all posts they create!
     * If you only want to label their profile, use the {@link labelProfile} method.
     * @param labels The labels to apply.
     * @param comment An optional comment to attach to the label.
     */
    async labelAccount(labels, comment) {
        return this.bot.label({ reference: { did: this.did }, labels, comment });
    }
    /**
     * Negate labels previously applied to the user's account.
     * @param labels The labels to negate.
     * @param comment An optional comment to attach.
     */
    async negateAccountLabels(labels, comment) {
        return this.bot.negateLabels({ reference: { did: this.did }, labels, comment });
    }
    /**
     * Apply labels to the user's profile only. If you wish to apply an account-level label that will also appear on all
     * posts the user creates, use the {@link labelAccount} method. Note that you need a running Ozone instance to publish labels!
     * @param labels The labels to apply.
     * @param comment An optional comment to attach to the label.
     */
    async labelProfile(labels, comment) {
        const profileRecordResponse = await this.bot.agent.get("com.atproto.repo.getRecord", {
            params: { repo: this.did, collection: "app.bsky.actor.profile", rkey: "self" },
        }).catch(() => null);
        if (!profileRecordResponse?.data?.cid) {
            throw new Error(`Could not find profile record for user ${this.did}.`);
        }
        const { uri, cid } = profileRecordResponse.data;
        return this.bot.label({ reference: { uri, cid }, labels, comment });
    }
    /**
     * Negate labels previously applied to the user's profile.
     * @param labels The labels to negate.
     * @param comment An optional comment to attach.
     */
    async negateProfileLabels(labels, comment) {
        const profileRecordResponse = await this.bot.agent.get("com.atproto.repo.getRecord", {
            params: { repo: this.did, collection: "app.bsky.actor.profile", rkey: "self" },
        }).catch(() => null);
        if (!profileRecordResponse?.data?.cid) {
            throw new Error(`Could not find profile record for user ${this.did}.`);
        }
        const { uri, cid } = profileRecordResponse.data;
        return this.bot.negateLabels({ reference: { uri, cid }, labels, comment });
    }
    /**
     * Constructs an instance from a ProfileView.
     * @param view The ProfileView to construct from.
     * @param bot The active Bot instance.
     */
    static fromView(view, bot) {
        return new Profile({
            ...view,
            labels: view.labels ?? [],
            indexedAt: "indexedAt" in view ? new Date(view.indexedAt) : undefined,
            followerCount: "followersCount" in view ? view.followersCount : undefined,
            followingCount: "followsCount" in view ? view.followsCount : undefined,
            postsCount: "postsCount" in view ? view.postsCount : undefined,
            followUri: view.viewer?.following,
            followedByUri: view.viewer?.followedBy,
            isMuted: view.viewer?.muted,
            blockUri: view.viewer?.blocking,
            isBlockedBy: view.viewer?.blockedBy,
            isLabeler: view.associated?.labeler,
            incomingChatPreference: view.associated?.chat?.allowIncoming,
        }, bot);
    }
}
/**
 * A user's preference for who can initiate a chat conversation.
 * @enum
 */
export const IncomingChatPreference = {
    /** Receive messages from everyone. */
    All: "all",
    /** Receive messages from nobody. */
    None: "none",
    /** Receive messages from users the user follows. */
    Following: "following",
};
