import * as CBOR from '@atcute/cbor';
import * as varint from '@atcute/varint';
import * as CID from '@atcute/cid';
const isCarV1Header = (value) => {
    if (value === null || typeof value !== 'object') {
        return false;
    }
    const { version, roots } = value;
    return version === 1 && Array.isArray(roots) && roots.every((root) => root instanceof CBOR.CIDLinkWrapper);
};
const readVarint = (reader, size) => {
    const buf = reader.upto(size);
    if (buf.length === 0) {
        throw new RangeError(`unexpected end of data`);
    }
    const [int, read] = varint.decode(buf);
    reader.seek(read);
    return int;
};
const readHeader = (reader) => {
    const length = readVarint(reader, 8);
    if (length === 0) {
        throw new RangeError(`invalid car header; length=0`);
    }
    const rawHeader = reader.exactly(length, true);
    const header = CBOR.decode(rawHeader);
    if (!isCarV1Header(header)) {
        throw new TypeError(`expected a car v1 archive`);
    }
    return header;
};
const readMultihashDigest = (reader) => {
    const first = reader.upto(8);
    const [code, codeOffset] = varint.decode(first);
    const [size, sizeOffset] = varint.decode(first.subarray(codeOffset));
    const offset = codeOffset + sizeOffset;
    const bytes = reader.exactly(offset + size, true);
    const digest = bytes.subarray(offset);
    return {
        code: code,
        size: size,
        digest: digest,
        bytes: bytes,
    };
};
const readCid = (reader) => {
    const version = readVarint(reader, 8);
    if (version !== 1) {
        throw new Error(`expected a cidv1`);
    }
    const codec = readVarint(reader, 8);
    const digest = readMultihashDigest(reader);
    const cid = {
        version: version,
        code: codec,
        digest: digest,
        bytes: CID.encode(version, codec, digest.bytes),
    };
    return cid;
};
const readBlockHeader = (reader) => {
    const start = reader.pos;
    let size = readVarint(reader, 8);
    if (size === 0) {
        throw new Error(`invalid car section; length=0`);
    }
    size += reader.pos - start;
    const cid = readCid(reader);
    const blockSize = size - Number(reader.pos - start);
    return { cid, blockSize };
};
export const createCarReader = (reader) => {
    const { roots } = readHeader(reader);
    return {
        roots,
        *iterate() {
            while (reader.upto(8).length > 0) {
                const { cid, blockSize } = readBlockHeader(reader);
                const bytes = reader.exactly(blockSize, true);
                yield { cid, bytes };
            }
        },
    };
};
//# sourceMappingURL=sync-car-reader.js.map