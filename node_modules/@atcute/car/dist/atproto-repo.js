import * as CBOR from '@atcute/cbor';
import * as CID from '@atcute/cid';
import { readCar } from './reader.js';
const decoder = new TextDecoder();
export class RepoEntry {
    collection;
    rkey;
    cid;
    blockmap;
    constructor(collection, rkey, cid, blockmap) {
        this.collection = collection;
        this.rkey = rkey;
        this.cid = cid;
        this.blockmap = blockmap;
    }
    get record() {
        return readObject(this.blockmap, this.cid);
    }
}
export function* iterateAtpRepo(buf) {
    const { roots, iterate } = readCar(new Uint8Array(buf));
    assert(roots.length === 1, `expected only 1 root in the car archive; got=${roots.length}`);
    // Collect all archive entries into a mapping of CID string -> actual bytes
    const blockmap = new Map();
    for (const entry of iterate()) {
        blockmap.set(CID.format(entry.cid), entry.bytes);
    }
    // Read the head, then walk through the MST tree from there.
    const commit = readObject(blockmap, roots[0]);
    for (const { key, cid } of walkEntries(blockmap, commit.data)) {
        const [collection, rkey] = key.split('/');
        yield new RepoEntry(collection, rkey, cid, blockmap);
    }
}
/** @deprecated Use `iterateAtpRepo` instead */
export const iterateAtpCar = iterateAtpRepo;
function readObject(map, link) {
    const cid = link.$link;
    const bytes = map.get(cid);
    assert(bytes != null, `cid not found in blockmap; cid=${cid}`);
    const data = CBOR.decode(bytes);
    return data;
}
function* walkEntries(map, pointer) {
    const data = readObject(map, pointer);
    const entries = data.e;
    let lastKey = '';
    if (data.l !== null) {
        yield* walkEntries(map, data.l);
    }
    for (let i = 0, il = entries.length; i < il; i++) {
        const entry = entries[i];
        const key_str = decoder.decode(CBOR.fromBytes(entry.k));
        const key = lastKey.slice(0, entry.p) + key_str;
        lastKey = key;
        yield { key: key, cid: entry.v };
        if (entry.t !== null) {
            yield* walkEntries(map, entry.t);
        }
    }
}
function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}
//# sourceMappingURL=atproto-repo.js.map