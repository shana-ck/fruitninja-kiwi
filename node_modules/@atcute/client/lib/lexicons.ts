/* eslint-disable */
// This file is automatically generated, do not edit!

/**
 * @module
 * Contains type declarations for AT Protocol lexicons
 */

type ObjectOmit<T, K extends keyof any> = Omit<T, K>;

/** Handles type branding in objects */
export declare namespace Brand {
	/** Symbol used to brand objects, this does not actually exist in runtime */
	const Type: unique symbol;

	/** Get the intended `$type` field */
	type GetType<T extends { [Type]?: string }> = NonNullable<T[typeof Type]>;

	/** Creates a union of objects where it's discriminated by `$type` field. */
	type Union<T extends { [Type]?: string }> = T extends any ? T & { $type: GetType<T> } : never;

	/** Omits the type branding from object */
	type Omit<T extends { [Type]?: string }> = ObjectOmit<T, typeof Type>;
}

/** Base AT Protocol schema types */
export declare namespace At {
	/** CID string */
	type CID = string;

	/** DID of a user */
	type DID = `did:${string}`;

	/** User handle */
	type Handle = string;

	/** URI string */
	type Uri = string;

	/** Object containing a CID string */
	interface CIDLink {
		$link: CID;
	}

	/** Object containing a base64-encoded bytes */
	interface Bytes {
		$bytes: string;
	}

	/** Blob interface */
	interface Blob<T extends string = string> {
		$type: 'blob';
		mimeType: T;
		ref: {
			$link: string;
		};
		size: number;
	}
}
export declare namespace ComAtprotoAdminDefs {
	interface AccountView {
		[Brand.Type]?: 'com.atproto.admin.defs#accountView';
		did: At.DID;
		handle: At.Handle;
		indexedAt: string;
		deactivatedAt?: string;
		email?: string;
		emailConfirmedAt?: string;
		invitedBy?: ComAtprotoServerDefs.InviteCode;
		inviteNote?: string;
		invites?: ComAtprotoServerDefs.InviteCode[];
		invitesDisabled?: boolean;
		relatedRecords?: unknown[];
	}
	interface RepoBlobRef {
		[Brand.Type]?: 'com.atproto.admin.defs#repoBlobRef';
		cid: At.CID;
		did: At.DID;
		recordUri?: At.Uri;
	}
	interface RepoRef {
		[Brand.Type]?: 'com.atproto.admin.defs#repoRef';
		did: At.DID;
	}
	interface StatusAttr {
		[Brand.Type]?: 'com.atproto.admin.defs#statusAttr';
		applied: boolean;
		ref?: string;
	}
}

/** Delete a user account as an administrator. */
export declare namespace ComAtprotoAdminDeleteAccount {
	interface Params {}
	interface Input {
		did: At.DID;
	}
	type Output = undefined;
}

/** Disable an account from receiving new invite codes, but does not invalidate existing codes. */
export declare namespace ComAtprotoAdminDisableAccountInvites {
	interface Params {}
	interface Input {
		account: At.DID;
		/** Optional reason for disabled invites. */
		note?: string;
	}
	type Output = undefined;
}

/** Disable some set of codes and/or all codes associated with a set of users. */
export declare namespace ComAtprotoAdminDisableInviteCodes {
	interface Params {}
	interface Input {
		accounts?: string[];
		codes?: string[];
	}
	type Output = undefined;
}

/** Re-enable an account's ability to receive invite codes. */
export declare namespace ComAtprotoAdminEnableAccountInvites {
	interface Params {}
	interface Input {
		account: At.DID;
		/** Optional reason for enabled invites. */
		note?: string;
	}
	type Output = undefined;
}

/** Get details about an account. */
export declare namespace ComAtprotoAdminGetAccountInfo {
	interface Params {
		did: At.DID;
	}
	type Input = undefined;
	type Output = ComAtprotoAdminDefs.AccountView;
}

/** Get details about some accounts. */
export declare namespace ComAtprotoAdminGetAccountInfos {
	interface Params {
		dids: At.DID[];
	}
	type Input = undefined;
	interface Output {
		infos: ComAtprotoAdminDefs.AccountView[];
	}
}

/** Get an admin view of invite codes. */
export declare namespace ComAtprotoAdminGetInviteCodes {
	interface Params {
		cursor?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 500
		 * @default 100
		 */
		limit?: number;
		/** @default "recent" */
		sort?: 'recent' | 'usage' | (string & {});
	}
	type Input = undefined;
	interface Output {
		codes: ComAtprotoServerDefs.InviteCode[];
		cursor?: string;
	}
}

/** Get the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminGetSubjectStatus {
	interface Params {
		blob?: At.CID;
		did?: At.DID;
		uri?: At.Uri;
	}
	type Input = undefined;
	interface Output {
		subject: Brand.Union<
			ComAtprotoAdminDefs.RepoBlobRef | ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
		>;
		deactivated?: ComAtprotoAdminDefs.StatusAttr;
		takedown?: ComAtprotoAdminDefs.StatusAttr;
	}
}

/** Get list of accounts that matches your search query. */
export declare namespace ComAtprotoAdminSearchAccounts {
	interface Params {
		cursor?: string;
		email?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
	}
	type Input = undefined;
	interface Output {
		accounts: ComAtprotoAdminDefs.AccountView[];
		cursor?: string;
	}
}

/** Send email to a user's account email address. */
export declare namespace ComAtprotoAdminSendEmail {
	interface Params {}
	interface Input {
		content: string;
		recipientDid: At.DID;
		senderDid: At.DID;
		/** Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers */
		comment?: string;
		subject?: string;
	}
	interface Output {
		sent: boolean;
	}
}

/** Administrative action to update an account's email. */
export declare namespace ComAtprotoAdminUpdateAccountEmail {
	interface Params {}
	interface Input {
		/** The handle or DID of the repo. */
		account: string;
		email: string;
	}
	type Output = undefined;
}

/** Administrative action to update an account's handle. */
export declare namespace ComAtprotoAdminUpdateAccountHandle {
	interface Params {}
	interface Input {
		did: At.DID;
		handle: At.Handle;
	}
	type Output = undefined;
}

/** Update the password for a user account as an administrator. */
export declare namespace ComAtprotoAdminUpdateAccountPassword {
	interface Params {}
	interface Input {
		did: At.DID;
		password: string;
	}
	type Output = undefined;
}

/** Update the service-specific admin status of a subject (account, record, or blob). */
export declare namespace ComAtprotoAdminUpdateSubjectStatus {
	interface Params {}
	interface Input {
		subject: Brand.Union<
			ComAtprotoAdminDefs.RepoBlobRef | ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
		>;
		deactivated?: ComAtprotoAdminDefs.StatusAttr;
		takedown?: ComAtprotoAdminDefs.StatusAttr;
	}
	interface Output {
		subject: Brand.Union<
			ComAtprotoAdminDefs.RepoBlobRef | ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main
		>;
		takedown?: ComAtprotoAdminDefs.StatusAttr;
	}
}

/** Describe the credentials that should be included in the DID doc of an account that is migrating to this service. */
export declare namespace ComAtprotoIdentityGetRecommendedDidCredentials {
	interface Params {}
	type Input = undefined;
	interface Output {
		alsoKnownAs?: string[];
		/** Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs. */
		rotationKeys?: string[];
		services?: unknown;
		verificationMethods?: unknown;
	}
}

/** Request an email with a code to in order to request a signed PLC operation. Requires Auth. */
export declare namespace ComAtprotoIdentityRequestPlcOperationSignature {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Resolves a handle (domain name) to a DID. */
export declare namespace ComAtprotoIdentityResolveHandle {
	interface Params {
		/** The handle to resolve. */
		handle: At.Handle;
	}
	type Input = undefined;
	interface Output {
		did: At.DID;
	}
}

/** Signs a PLC operation to update some value(s) in the requesting DID's document. */
export declare namespace ComAtprotoIdentitySignPlcOperation {
	interface Params {}
	interface Input {
		alsoKnownAs?: string[];
		rotationKeys?: string[];
		services?: unknown;
		/** A token received through com.atproto.identity.requestPlcOperationSignature */
		token?: string;
		verificationMethods?: unknown;
	}
	interface Output {
		/** A signed DID PLC operation. */
		operation: unknown;
	}
}

/** Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry */
export declare namespace ComAtprotoIdentitySubmitPlcOperation {
	interface Params {}
	interface Input {
		operation: unknown;
	}
	type Output = undefined;
}

/** Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth. */
export declare namespace ComAtprotoIdentityUpdateHandle {
	interface Params {}
	interface Input {
		/** The new handle. */
		handle: At.Handle;
	}
	type Output = undefined;
}

export declare namespace ComAtprotoLabelDefs {
	/** Metadata tag on an atproto resource (eg, repo or record). */
	interface Label {
		[Brand.Type]?: 'com.atproto.label.defs#label';
		/** Timestamp when this label was created. */
		cts: string;
		/** DID of the actor who created this label. */
		src: At.DID;
		/** AT URI of the record, repository (account), or other resource that this label applies to. */
		uri: string;
		/**
		 * The short string name of the value or type of this label. \
		 * Maximum string length: 128
		 */
		val: string;
		/** Optionally, CID specifying the specific version of 'uri' resource this label applies to. */
		cid?: At.CID;
		/** Timestamp at which this label expires (no longer applies). */
		exp?: string;
		/** If true, this is a negation label, overwriting a previous label. */
		neg?: boolean;
		/** Signature of dag-cbor encoded label. */
		sig?: At.Bytes;
		/** The AT Protocol version of the label object. */
		ver?: number;
	}
	type LabelValue =
		| '!hide'
		| '!no-promote'
		| '!no-unauthenticated'
		| '!warn'
		| 'dmca-violation'
		| 'doxxing'
		| 'gore'
		| 'nsfl'
		| 'nudity'
		| 'porn'
		| 'sexual'
		| (string & {});
	/** Declares a label value and its expected interpretations and behaviors. */
	interface LabelValueDefinition {
		[Brand.Type]?: 'com.atproto.label.defs#labelValueDefinition';
		/** What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing. */
		blurs: 'content' | 'media' | 'none' | (string & {});
		/**
		 * The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+). \
		 * Maximum string length: 100 \
		 * Maximum grapheme length: 100
		 */
		identifier: string;
		locales: LabelValueDefinitionStrings[];
		/** How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing. */
		severity: 'alert' | 'inform' | 'none' | (string & {});
		/** Does the user need to have adult content enabled in order to configure this label? */
		adultOnly?: boolean;
		/**
		 * The default setting for this label.
		 * @default "warn"
		 */
		defaultSetting?: 'hide' | 'ignore' | 'warn' | (string & {});
	}
	/** Strings which describe the label in the UI, localized into a specific language. */
	interface LabelValueDefinitionStrings {
		[Brand.Type]?: 'com.atproto.label.defs#labelValueDefinitionStrings';
		/**
		 * A longer description of what the label means and why it might be applied. \
		 * Maximum string length: 100000 \
		 * Maximum grapheme length: 10000
		 */
		description: string;
		/** The code of the language these strings are written in. */
		lang: string;
		/**
		 * A short human-readable name for the label. \
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		name: string;
	}
	/** Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel. */
	interface SelfLabel {
		[Brand.Type]?: 'com.atproto.label.defs#selfLabel';
		/**
		 * The short string name of the value or type of this label. \
		 * Maximum string length: 128
		 */
		val: string;
	}
	/** Metadata tags on an atproto record, published by the author within the record. */
	interface SelfLabels {
		[Brand.Type]?: 'com.atproto.label.defs#selfLabels';
		/** Maximum array length: 10 */
		values: SelfLabel[];
	}
}

/** Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth. */
export declare namespace ComAtprotoLabelQueryLabels {
	interface Params {
		/** List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI. */
		uriPatterns: string[];
		cursor?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 250
		 * @default 50
		 */
		limit?: number;
		/** Optional list of label sources (DIDs) to filter on. */
		sources?: At.DID[];
	}
	type Input = undefined;
	interface Output {
		labels: ComAtprotoLabelDefs.Label[];
		cursor?: string;
	}
}

export declare namespace ComAtprotoLabelSubscribeLabels {
	interface Info {
		[Brand.Type]?: 'com.atproto.label.subscribeLabels#info';
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	}
	interface Labels {
		[Brand.Type]?: 'com.atproto.label.subscribeLabels#labels';
		labels: ComAtprotoLabelDefs.Label[];
		seq: number;
	}
}

/** Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth. */
export declare namespace ComAtprotoModerationCreateReport {
	interface Params {}
	interface Input {
		/** Indicates the broad category of violation the report is for. */
		reasonType: ComAtprotoModerationDefs.ReasonType;
		subject: Brand.Union<ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main>;
		/**
		 * Additional context about the content and violation. \
		 * Maximum string length: 20000 \
		 * Maximum grapheme length: 2000
		 */
		reason?: string;
	}
	interface Output {
		createdAt: string;
		id: number;
		reasonType: ComAtprotoModerationDefs.ReasonType;
		reportedBy: At.DID;
		subject: Brand.Union<ComAtprotoAdminDefs.RepoRef | ComAtprotoRepoStrongRef.Main>;
		/**
		 * Maximum string length: 20000 \
		 * Maximum grapheme length: 2000
		 */
		reason?: string;
	}
}

export declare namespace ComAtprotoModerationDefs {
	type ReasonAppeal = 'com.atproto.moderation.defs#reasonAppeal';
	type ReasonMisleading = 'com.atproto.moderation.defs#reasonMisleading';
	type ReasonOther = 'com.atproto.moderation.defs#reasonOther';
	type ReasonRude = 'com.atproto.moderation.defs#reasonRude';
	type ReasonSexual = 'com.atproto.moderation.defs#reasonSexual';
	type ReasonSpam = 'com.atproto.moderation.defs#reasonSpam';
	type ReasonType =
		| 'com.atproto.moderation.defs#reasonAppeal'
		| 'com.atproto.moderation.defs#reasonMisleading'
		| 'com.atproto.moderation.defs#reasonOther'
		| 'com.atproto.moderation.defs#reasonRude'
		| 'com.atproto.moderation.defs#reasonSexual'
		| 'com.atproto.moderation.defs#reasonSpam'
		| 'com.atproto.moderation.defs#reasonViolation'
		| (string & {});
	type ReasonViolation = 'com.atproto.moderation.defs#reasonViolation';
}

/** Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoApplyWrites {
	interface Params {}
	interface Input {
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		writes: Brand.Union<Create | Delete | Update>[];
		/** If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations. */
		swapCommit?: At.CID;
		/** Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons. */
		validate?: boolean;
	}
	interface Output {
		commit?: ComAtprotoRepoDefs.CommitMeta;
		results?: Brand.Union<CreateResult | DeleteResult | UpdateResult>[];
	}
	interface Errors {
		InvalidSwap: {};
	}
	/** Operation which creates a new record. */
	interface Create {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#create';
		collection: string;
		value: unknown;
		/** Maximum string length: 15 */
		rkey?: string;
	}
	interface CreateResult {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#createResult';
		cid: At.CID;
		uri: At.Uri;
		validationStatus?: 'unknown' | 'valid' | (string & {});
	}
	/** Operation which deletes an existing record. */
	interface Delete {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#delete';
		collection: string;
		rkey: string;
	}
	interface DeleteResult {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#deleteResult';
	}
	/** Operation which updates an existing record. */
	interface Update {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#update';
		collection: string;
		rkey: string;
		value: unknown;
	}
	interface UpdateResult {
		[Brand.Type]?: 'com.atproto.repo.applyWrites#updateResult';
		cid: At.CID;
		uri: At.Uri;
		validationStatus?: 'unknown' | 'valid' | (string & {});
	}
}

/** Create a single new repository record. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoCreateRecord {
	interface Params {}
	interface Input {
		/** The NSID of the record collection. */
		collection: string;
		/** The record itself. Must contain a $type field. */
		record: unknown;
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		/**
		 * The Record Key. \
		 * Maximum string length: 15
		 */
		rkey?: string;
		/** Compare and swap with the previous commit by CID. */
		swapCommit?: At.CID;
		/** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
		validate?: boolean;
	}
	interface Output {
		cid: At.CID;
		uri: At.Uri;
		commit?: ComAtprotoRepoDefs.CommitMeta;
		validationStatus?: 'unknown' | 'valid' | (string & {});
	}
	interface Errors {
		InvalidSwap: {};
	}
}

export declare namespace ComAtprotoRepoDefs {
	interface CommitMeta {
		[Brand.Type]?: 'com.atproto.repo.defs#commitMeta';
		cid: At.CID;
		rev: string;
	}
}

/** Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoDeleteRecord {
	interface Params {}
	interface Input {
		/** The NSID of the record collection. */
		collection: string;
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		/** The Record Key. */
		rkey: string;
		/** Compare and swap with the previous commit by CID. */
		swapCommit?: At.CID;
		/** Compare and swap with the previous record by CID. */
		swapRecord?: At.CID;
	}
	interface Output {
		commit?: ComAtprotoRepoDefs.CommitMeta;
	}
	interface Errors {
		InvalidSwap: {};
	}
}

/** Get information about an account and repository, including the list of collections. Does not require auth. */
export declare namespace ComAtprotoRepoDescribeRepo {
	interface Params {
		/** The handle or DID of the repo. */
		repo: string;
	}
	type Input = undefined;
	interface Output {
		/** List of all the collections (NSIDs) for which this repo contains at least one record. */
		collections: string[];
		did: At.DID;
		/** The complete DID document for this account. */
		didDoc: unknown;
		handle: At.Handle;
		/** Indicates if handle is currently valid (resolves bi-directionally) */
		handleIsCorrect: boolean;
	}
}

/** Get a single record from a repository. Does not require auth. */
export declare namespace ComAtprotoRepoGetRecord {
	interface Params {
		/** The NSID of the record collection. */
		collection: string;
		/** The handle or DID of the repo. */
		repo: string;
		/** The Record Key. */
		rkey: string;
		/** The CID of the version of the record. If not specified, then return the most recent version. */
		cid?: At.CID;
	}
	type Input = undefined;
	interface Output {
		uri: At.Uri;
		value: unknown;
		cid?: At.CID;
	}
	interface Errors {
		RecordNotFound: {};
	}
}

/** Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set. */
export declare namespace ComAtprotoRepoImportRepo {
	interface Params {}
	type Input = Blob | ArrayBufferView;
	type Output = undefined;
}

/** Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow. */
export declare namespace ComAtprotoRepoListMissingBlobs {
	interface Params {
		cursor?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 1000
		 * @default 500
		 */
		limit?: number;
	}
	type Input = undefined;
	interface Output {
		blobs: RecordBlob[];
		cursor?: string;
	}
	interface RecordBlob {
		[Brand.Type]?: 'com.atproto.repo.listMissingBlobs#recordBlob';
		cid: At.CID;
		recordUri: At.Uri;
	}
}

/** List a range of records in a repository, matching a specific collection. Does not require auth. */
export declare namespace ComAtprotoRepoListRecords {
	interface Params {
		/** The NSID of the record type. */
		collection: string;
		/** The handle or DID of the repo. */
		repo: string;
		cursor?: string;
		/**
		 * The number of records to return. \
		 * Minimum: 1 \
		 * Maximum: 100
		 * @default 50
		 */
		limit?: number;
		/** Flag to reverse the order of the returned records. */
		reverse?: boolean;
		/**
		 * DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)
		 * @deprecated
		 */
		rkeyEnd?: string;
		/**
		 * DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)
		 * @deprecated
		 */
		rkeyStart?: string;
	}
	type Input = undefined;
	interface Output {
		records: Record[];
		cursor?: string;
	}
	interface Record {
		[Brand.Type]?: 'com.atproto.repo.listRecords#record';
		cid: At.CID;
		uri: At.Uri;
		value: unknown;
	}
}

/** Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoPutRecord {
	interface Params {}
	interface Input {
		/** The NSID of the record collection. */
		collection: string;
		/** The record to write. */
		record: unknown;
		/** The handle or DID of the repo (aka, current account). */
		repo: string;
		/**
		 * The Record Key. \
		 * Maximum string length: 15
		 */
		rkey: string;
		/** Compare and swap with the previous commit by CID. */
		swapCommit?: At.CID;
		/** Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation */
		swapRecord?: At.CID | null;
		/** Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons. */
		validate?: boolean;
	}
	interface Output {
		cid: At.CID;
		uri: At.Uri;
		commit?: ComAtprotoRepoDefs.CommitMeta;
		validationStatus?: 'unknown' | 'valid' | (string & {});
	}
	interface Errors {
		InvalidSwap: {};
	}
}

export declare namespace ComAtprotoRepoStrongRef {
	interface Main {
		[Brand.Type]?: 'com.atproto.repo.strongRef';
		cid: At.CID;
		uri: At.Uri;
	}
}

/** Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS. */
export declare namespace ComAtprotoRepoUploadBlob {
	interface Params {}
	type Input = Blob | ArrayBufferView;
	interface Output {
		blob: At.Blob;
	}
}

/** Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup. */
export declare namespace ComAtprotoServerActivateAccount {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself. */
export declare namespace ComAtprotoServerCheckAccountStatus {
	interface Params {}
	type Input = undefined;
	interface Output {
		activated: boolean;
		expectedBlobs: number;
		importedBlobs: number;
		indexedRecords: number;
		privateStateValues: number;
		repoBlocks: number;
		repoCommit: At.CID;
		repoRev: string;
		validDid: boolean;
	}
}

/** Confirm an email using a token from com.atproto.server.requestEmailConfirmation. */
export declare namespace ComAtprotoServerConfirmEmail {
	interface Params {}
	interface Input {
		email: string;
		token: string;
	}
	type Output = undefined;
	interface Errors {
		AccountNotFound: {};
		ExpiredToken: {};
		InvalidToken: {};
		InvalidEmail: {};
	}
}

/** Create an account. Implemented by PDS. */
export declare namespace ComAtprotoServerCreateAccount {
	interface Params {}
	interface Input {
		/** Requested handle for the account. */
		handle: At.Handle;
		/** Pre-existing atproto DID, being imported to a new account. */
		did?: At.DID;
		email?: string;
		inviteCode?: string;
		/** Initial account password. May need to meet instance-specific password strength requirements. */
		password?: string;
		/** A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented. */
		plcOp?: unknown;
		/** DID PLC rotation key (aka, recovery key) to be included in PLC creation operation. */
		recoveryKey?: string;
		verificationCode?: string;
		verificationPhone?: string;
	}
	/** Account login session returned on successful account creation. */
	interface Output {
		accessJwt: string;
		/** The DID of the new account. */
		did: At.DID;
		handle: At.Handle;
		refreshJwt: string;
		/** Complete DID document. */
		didDoc?: unknown;
	}
	interface Errors {
		InvalidHandle: {};
		InvalidPassword: {};
		InvalidInviteCode: {};
		HandleNotAvailable: {};
		UnsupportedDomain: {};
		UnresolvableDid: {};
		IncompatibleDidDoc: {};
	}
}

/** Create an App Password. */
export declare namespace ComAtprotoServerCreateAppPassword {
	interface Params {}
	interface Input {
		/** A short name for the App Password, to help distinguish them. */
		name: string;
		/** If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients. */
		privileged?: boolean;
	}
	type Output = AppPassword;
	interface Errors {
		AccountTakedown: {};
	}
	interface AppPassword {
		[Brand.Type]?: 'com.atproto.server.createAppPassword#appPassword';
		createdAt: string;
		name: string;
		password: string;
		privileged?: boolean;
	}
}

/** Create an invite code. */
export declare namespace ComAtprotoServerCreateInviteCode {
	interface Params {}
	interface Input {
		useCount: number;
		forAccount?: At.DID;
	}
	interface Output {
		code: string;
	}
}

/** Create invite codes. */
export declare namespace ComAtprotoServerCreateInviteCodes {
	interface Params {}
	interface Input {
		/** @default 1 */
		codeCount: number;
		useCount: number;
		forAccounts?: At.DID[];
	}
	interface Output {
		codes: AccountCodes[];
	}
	interface AccountCodes {
		[Brand.Type]?: 'com.atproto.server.createInviteCodes#accountCodes';
		account: string;
		codes: string[];
	}
}

/** Create an authentication session. */
export declare namespace ComAtprotoServerCreateSession {
	interface Params {}
	interface Input {
		/** Handle or other identifier supported by the server for the authenticating user. */
		identifier: string;
		password: string;
		authFactorToken?: string;
	}
	interface Output {
		accessJwt: string;
		did: At.DID;
		handle: At.Handle;
		refreshJwt: string;
		active?: boolean;
		didDoc?: unknown;
		email?: string;
		emailAuthFactor?: boolean;
		emailConfirmed?: boolean;
		/** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
		status?: 'deactivated' | 'suspended' | 'takendown' | (string & {});
	}
	interface Errors {
		AccountTakedown: {};
		AuthFactorTokenRequired: {};
	}
}

/** Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host. */
export declare namespace ComAtprotoServerDeactivateAccount {
	interface Params {}
	interface Input {
		/** A recommendation to server as to how long they should hold onto the deactivated account before deleting. */
		deleteAfter?: string;
	}
	type Output = undefined;
}

export declare namespace ComAtprotoServerDefs {
	interface InviteCode {
		[Brand.Type]?: 'com.atproto.server.defs#inviteCode';
		available: number;
		code: string;
		createdAt: string;
		createdBy: string;
		disabled: boolean;
		forAccount: string;
		uses: InviteCodeUse[];
	}
	interface InviteCodeUse {
		[Brand.Type]?: 'com.atproto.server.defs#inviteCodeUse';
		usedAt: string;
		usedBy: At.DID;
	}
}

/** Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth. */
export declare namespace ComAtprotoServerDeleteAccount {
	interface Params {}
	interface Input {
		did: At.DID;
		password: string;
		token: string;
	}
	type Output = undefined;
	interface Errors {
		ExpiredToken: {};
		InvalidToken: {};
	}
}

/** Delete the current session. Requires auth. */
export declare namespace ComAtprotoServerDeleteSession {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Describes the server's account creation requirements and capabilities. Implemented by PDS. */
export declare namespace ComAtprotoServerDescribeServer {
	interface Params {}
	type Input = undefined;
	interface Output {
		/** List of domain suffixes that can be used in account handles. */
		availableUserDomains: string[];
		did: At.DID;
		/** Contact information */
		contact?: Contact;
		/** If true, an invite code must be supplied to create an account on this instance. */
		inviteCodeRequired?: boolean;
		/** URLs of service policy documents. */
		links?: Links;
		/** If true, a phone verification token must be supplied to create an account on this instance. */
		phoneVerificationRequired?: boolean;
	}
	interface Contact {
		[Brand.Type]?: 'com.atproto.server.describeServer#contact';
		email?: string;
	}
	interface Links {
		[Brand.Type]?: 'com.atproto.server.describeServer#links';
		privacyPolicy?: string;
		termsOfService?: string;
	}
}

/** Get all invite codes for the current account. Requires auth. */
export declare namespace ComAtprotoServerGetAccountInviteCodes {
	interface Params {
		/**
		 * Controls whether any new 'earned' but not 'created' invites should be created.
		 * @default true
		 */
		createAvailable?: boolean;
		/** @default true */
		includeUsed?: boolean;
	}
	type Input = undefined;
	interface Output {
		codes: ComAtprotoServerDefs.InviteCode[];
	}
	interface Errors {
		DuplicateCreate: {};
	}
}

/** Get a signed token on behalf of the requesting DID for the requested service. */
export declare namespace ComAtprotoServerGetServiceAuth {
	interface Params {
		/** The DID of the service that the token will be used to authenticate with */
		aud: At.DID;
		/** The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope. */
		exp?: number;
		/** Lexicon (XRPC) method to bind the requested token to */
		lxm?: string;
	}
	type Input = undefined;
	interface Output {
		token: string;
	}
	interface Errors {
		BadExpiration: {};
	}
}

/** Get information about the current auth session. Requires auth. */
export declare namespace ComAtprotoServerGetSession {
	interface Params {}
	type Input = undefined;
	interface Output {
		did: At.DID;
		handle: At.Handle;
		active?: boolean;
		didDoc?: unknown;
		email?: string;
		emailAuthFactor?: boolean;
		emailConfirmed?: boolean;
		/** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
		status?: 'deactivated' | 'suspended' | 'takendown' | (string & {});
	}
}

/** List all App Passwords. */
export declare namespace ComAtprotoServerListAppPasswords {
	interface Params {}
	type Input = undefined;
	interface Output {
		passwords: AppPassword[];
	}
	interface Errors {
		AccountTakedown: {};
	}
	interface AppPassword {
		[Brand.Type]?: 'com.atproto.server.listAppPasswords#appPassword';
		createdAt: string;
		name: string;
		privileged?: boolean;
	}
}

/** Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt'). */
export declare namespace ComAtprotoServerRefreshSession {
	interface Params {}
	type Input = undefined;
	interface Output {
		accessJwt: string;
		did: At.DID;
		handle: At.Handle;
		refreshJwt: string;
		active?: boolean;
		didDoc?: unknown;
		/** Hosting status of the account. If not specified, then assume 'active'. */
		status?: 'deactivated' | 'suspended' | 'takendown' | (string & {});
	}
	interface Errors {
		AccountTakedown: {};
	}
}

/** Initiate a user account deletion via email. */
export declare namespace ComAtprotoServerRequestAccountDelete {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Request an email with a code to confirm ownership of email. */
export declare namespace ComAtprotoServerRequestEmailConfirmation {
	interface Params {}
	type Input = undefined;
	type Output = undefined;
}

/** Request a token in order to update email. */
export declare namespace ComAtprotoServerRequestEmailUpdate {
	interface Params {}
	type Input = undefined;
	interface Output {
		tokenRequired: boolean;
	}
}

/** Initiate a user account password reset via email. */
export declare namespace ComAtprotoServerRequestPasswordReset {
	interface Params {}
	interface Input {
		email: string;
	}
	type Output = undefined;
}

/** Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented. */
export declare namespace ComAtprotoServerReserveSigningKey {
	interface Params {}
	interface Input {
		/** The DID to reserve a key for. */
		did?: At.DID;
	}
	interface Output {
		/** The public key for the reserved signing key, in did:key serialization. */
		signingKey: string;
	}
}

/** Reset a user account password using a token. */
export declare namespace ComAtprotoServerResetPassword {
	interface Params {}
	interface Input {
		password: string;
		token: string;
	}
	type Output = undefined;
	interface Errors {
		ExpiredToken: {};
		InvalidToken: {};
	}
}

/** Revoke an App Password by name. */
export declare namespace ComAtprotoServerRevokeAppPassword {
	interface Params {}
	interface Input {
		name: string;
	}
	type Output = undefined;
}

/** Update an account's email. */
export declare namespace ComAtprotoServerUpdateEmail {
	interface Params {}
	interface Input {
		email: string;
		emailAuthFactor?: boolean;
		/** Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed. */
		token?: string;
	}
	type Output = undefined;
	interface Errors {
		ExpiredToken: {};
		InvalidToken: {};
		TokenRequired: {};
	}
}

/** Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlob {
	interface Params {
		/** The CID of the blob to fetch */
		cid: At.CID;
		/** The DID of the account. */
		did: At.DID;
	}
	type Input = undefined;
	type Output = Uint8Array;
	interface Errors {
		BlobNotFound: {};
		RepoNotFound: {};
		RepoTakendown: {};
		RepoSuspended: {};
		RepoDeactivated: {};
	}
}

/** Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetBlocks {
	interface Params {
		cids: At.CID[];
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	type Output = Uint8Array;
	interface Errors {
		BlockNotFound: {};
		RepoNotFound: {};
		RepoTakendown: {};
		RepoSuspended: {};
		RepoDeactivated: {};
	}
}

/**
 * DEPRECATED - please use com.atproto.sync.getRepo instead
 * @deprecated
 */
export declare namespace ComAtprotoSyncGetCheckout {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	type Output = Uint8Array;
}

/**
 * DEPRECATED - please use com.atproto.sync.getLatestCommit instead
 * @deprecated
 */
export declare namespace ComAtprotoSyncGetHead {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	interface Output {
		root: At.CID;
	}
	interface Errors {
		HeadNotFound: {};
	}
}

/** Get the current commit CID & revision of the specified repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetLatestCommit {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	interface Output {
		cid: At.CID;
		rev: string;
	}
	interface Errors {
		RepoNotFound: {};
		RepoTakendown: {};
		RepoSuspended: {};
		RepoDeactivated: {};
	}
}

/** Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth. */
export declare namespace ComAtprotoSyncGetRecord {
	interface Params {
		collection: string;
		/** The DID of the repo. */
		did: At.DID;
		/** Record Key */
		rkey: string;
		/**
		 * DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit
		 * @deprecated
		 */
		commit?: At.CID;
	}
	type Input = undefined;
	type Output = Uint8Array;
	interface Errors {
		RecordNotFound: {};
		RepoNotFound: {};
		RepoTakendown: {};
		RepoSuspended: {};
		RepoDeactivated: {};
	}
}

/** Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncGetRepo {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
		/** The revision ('rev') of the repo to create a diff from. */
		since?: string;
	}
	type Input = undefined;
	type Output = Uint8Array;
	interface Errors {
		RepoNotFound: {};
		RepoTakendown: {};
		RepoSuspended: {};
		RepoDeactivated: {};
	}
}

/** Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncGetRepoStatus {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
	}
	type Input = undefined;
	interface Output {
		active: boolean;
		did: At.DID;
		/** Optional field, the current rev of the repo, if active=true */
		rev?: string;
		/** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
		status?: 'deactivated' | 'suspended' | 'takendown' | (string & {});
	}
	interface Errors {
		RepoNotFound: {};
	}
}

/** List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS. */
export declare namespace ComAtprotoSyncListBlobs {
	interface Params {
		/** The DID of the repo. */
		did: At.DID;
		cursor?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 1000
		 * @default 500
		 */
		limit?: number;
		/** Optional revision of the repo to list blobs since. */
		since?: string;
	}
	type Input = undefined;
	interface Output {
		cids: At.CID[];
		cursor?: string;
	}
	interface Errors {
		RepoNotFound: {};
		RepoTakendown: {};
		RepoSuspended: {};
		RepoDeactivated: {};
	}
}

/** Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay. */
export declare namespace ComAtprotoSyncListRepos {
	interface Params {
		cursor?: string;
		/**
		 * Minimum: 1 \
		 * Maximum: 1000
		 * @default 500
		 */
		limit?: number;
	}
	type Input = undefined;
	interface Output {
		repos: Repo[];
		cursor?: string;
	}
	interface Repo {
		[Brand.Type]?: 'com.atproto.sync.listRepos#repo';
		did: At.DID;
		/** Current repo commit CID */
		head: At.CID;
		rev: string;
		active?: boolean;
		/** If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted. */
		status?: 'deactivated' | 'suspended' | 'takendown' | (string & {});
	}
}

/** Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay. */
export declare namespace ComAtprotoSyncNotifyOfUpdate {
	interface Params {}
	interface Input {
		/** Hostname of the current service (usually a PDS) that is notifying of update. */
		hostname: string;
	}
	type Output = undefined;
}

/** Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth. */
export declare namespace ComAtprotoSyncRequestCrawl {
	interface Params {}
	interface Input {
		/** Hostname of the current service (eg, PDS) that is requesting to be crawled. */
		hostname: string;
	}
	type Output = undefined;
}

export declare namespace ComAtprotoSyncSubscribeRepos {
	/** Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active. */
	interface Account {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#account';
		/** Indicates that the account has a repository which can be fetched from the host that emitted this event. */
		active: boolean;
		did: At.DID;
		seq: number;
		time: string;
		/** If active=false, this optional field indicates a reason for why the account is not active. */
		status?: 'deactivated' | 'deleted' | 'suspended' | 'takendown' | (string & {});
	}
	/** Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature. */
	interface Commit {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#commit';
		/** List of new blobs (by CID) referenced by records in this commit. */
		blobs: At.CIDLink[];
		/** CAR file containing relevant blocks, as a diff since the previous repo state. */
		blocks: At.Bytes;
		/** Repo commit object CID. */
		commit: At.CIDLink;
		/**
		 * Maximum array length: 200 \
		 * List of repo mutation operations in this commit (eg, records created, updated, or deleted).
		 */
		ops: RepoOp[];
		/**
		 * DEPRECATED -- unused
		 * @deprecated
		 */
		rebase: boolean;
		/** The repo this event comes from. */
		repo: At.DID;
		/** The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event. */
		rev: string;
		/** The stream sequence number of this message. */
		seq: number;
		/** The rev of the last emitted commit from this repo (if any). */
		since: string | null;
		/** Timestamp of when this message was originally broadcast. */
		time: string;
		/** Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data. */
		tooBig: boolean;
		/**
		 * DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability.
		 * @deprecated
		 */
		prev?: At.CIDLink | null;
	}
	/**
	 * DEPRECATED -- Use #identity event instead
	 * @deprecated
	 */
	interface Handle {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#handle';
		did: At.DID;
		handle: At.Handle;
		seq: number;
		time: string;
	}
	/** Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache. */
	interface Identity {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#identity';
		did: At.DID;
		seq: number;
		time: string;
		/** The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details. */
		handle?: At.Handle;
	}
	interface Info {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#info';
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	}
	/**
	 * DEPRECATED -- Use #account event instead
	 * @deprecated
	 */
	interface Migrate {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#migrate';
		did: At.DID;
		migrateTo: string | null;
		seq: number;
		time: string;
	}
	/** A repo operation, ie a mutation of a single record. */
	interface RepoOp {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#repoOp';
		action: 'create' | 'delete' | 'update' | (string & {});
		/** For creates and updates, the new record CID. For deletions, null. */
		cid: At.CIDLink | null;
		path: string;
	}
	/**
	 * DEPRECATED -- Use #account event instead
	 * @deprecated
	 */
	interface Tombstone {
		[Brand.Type]?: 'com.atproto.sync.subscribeRepos#tombstone';
		did: At.DID;
		seq: number;
		time: string;
	}
}

/** Check accounts location in signup queue. */
export declare namespace ComAtprotoTempCheckSignupQueue {
	interface Params {}
	type Input = undefined;
	interface Output {
		activated: boolean;
		estimatedTimeMs?: number;
		placeInQueue?: number;
	}
}

/**
 * DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.
 * @deprecated
 */
export declare namespace ComAtprotoTempFetchLabels {
	interface Params {
		/**
		 * Minimum: 1 \
		 * Maximum: 250
		 * @default 50
		 */
		limit?: number;
		since?: number;
	}
	type Input = undefined;
	interface Output {
		labels: ComAtprotoLabelDefs.Label[];
	}
}

/** Request a verification code to be sent to the supplied phone number */
export declare namespace ComAtprotoTempRequestPhoneVerification {
	interface Params {}
	interface Input {
		phoneNumber: string;
	}
	type Output = undefined;
}

export declare interface Records {}

export declare interface Queries {
	'com.atproto.admin.getAccountInfo': {
		params: ComAtprotoAdminGetAccountInfo.Params;
		output: ComAtprotoAdminGetAccountInfo.Output;
	};
	'com.atproto.admin.getAccountInfos': {
		params: ComAtprotoAdminGetAccountInfos.Params;
		output: ComAtprotoAdminGetAccountInfos.Output;
	};
	'com.atproto.admin.getInviteCodes': {
		params: ComAtprotoAdminGetInviteCodes.Params;
		output: ComAtprotoAdminGetInviteCodes.Output;
	};
	'com.atproto.admin.getSubjectStatus': {
		params: ComAtprotoAdminGetSubjectStatus.Params;
		output: ComAtprotoAdminGetSubjectStatus.Output;
	};
	'com.atproto.admin.searchAccounts': {
		params: ComAtprotoAdminSearchAccounts.Params;
		output: ComAtprotoAdminSearchAccounts.Output;
	};
	'com.atproto.identity.getRecommendedDidCredentials': {
		output: ComAtprotoIdentityGetRecommendedDidCredentials.Output;
	};
	'com.atproto.identity.resolveHandle': {
		params: ComAtprotoIdentityResolveHandle.Params;
		output: ComAtprotoIdentityResolveHandle.Output;
	};
	'com.atproto.label.queryLabels': {
		params: ComAtprotoLabelQueryLabels.Params;
		output: ComAtprotoLabelQueryLabels.Output;
	};
	'com.atproto.repo.describeRepo': {
		params: ComAtprotoRepoDescribeRepo.Params;
		output: ComAtprotoRepoDescribeRepo.Output;
	};
	'com.atproto.repo.getRecord': {
		params: ComAtprotoRepoGetRecord.Params;
		output: ComAtprotoRepoGetRecord.Output;
	};
	'com.atproto.repo.listMissingBlobs': {
		params: ComAtprotoRepoListMissingBlobs.Params;
		output: ComAtprotoRepoListMissingBlobs.Output;
	};
	'com.atproto.repo.listRecords': {
		params: ComAtprotoRepoListRecords.Params;
		output: ComAtprotoRepoListRecords.Output;
	};
	'com.atproto.server.checkAccountStatus': {
		output: ComAtprotoServerCheckAccountStatus.Output;
	};
	'com.atproto.server.describeServer': {
		output: ComAtprotoServerDescribeServer.Output;
	};
	'com.atproto.server.getAccountInviteCodes': {
		params: ComAtprotoServerGetAccountInviteCodes.Params;
		output: ComAtprotoServerGetAccountInviteCodes.Output;
	};
	'com.atproto.server.getServiceAuth': {
		params: ComAtprotoServerGetServiceAuth.Params;
		output: ComAtprotoServerGetServiceAuth.Output;
	};
	'com.atproto.server.getSession': {
		output: ComAtprotoServerGetSession.Output;
	};
	'com.atproto.server.listAppPasswords': {
		output: ComAtprotoServerListAppPasswords.Output;
	};
	'com.atproto.sync.getBlob': {
		params: ComAtprotoSyncGetBlob.Params;
		output: ComAtprotoSyncGetBlob.Output;
	};
	'com.atproto.sync.getBlocks': {
		params: ComAtprotoSyncGetBlocks.Params;
		output: ComAtprotoSyncGetBlocks.Output;
	};
	'com.atproto.sync.getCheckout': {
		params: ComAtprotoSyncGetCheckout.Params;
		output: ComAtprotoSyncGetCheckout.Output;
	};
	'com.atproto.sync.getHead': {
		params: ComAtprotoSyncGetHead.Params;
		output: ComAtprotoSyncGetHead.Output;
	};
	'com.atproto.sync.getLatestCommit': {
		params: ComAtprotoSyncGetLatestCommit.Params;
		output: ComAtprotoSyncGetLatestCommit.Output;
	};
	'com.atproto.sync.getRecord': {
		params: ComAtprotoSyncGetRecord.Params;
		output: ComAtprotoSyncGetRecord.Output;
	};
	'com.atproto.sync.getRepo': {
		params: ComAtprotoSyncGetRepo.Params;
		output: ComAtprotoSyncGetRepo.Output;
	};
	'com.atproto.sync.getRepoStatus': {
		params: ComAtprotoSyncGetRepoStatus.Params;
		output: ComAtprotoSyncGetRepoStatus.Output;
	};
	'com.atproto.sync.listBlobs': {
		params: ComAtprotoSyncListBlobs.Params;
		output: ComAtprotoSyncListBlobs.Output;
	};
	'com.atproto.sync.listRepos': {
		params: ComAtprotoSyncListRepos.Params;
		output: ComAtprotoSyncListRepos.Output;
	};
	'com.atproto.temp.checkSignupQueue': {
		output: ComAtprotoTempCheckSignupQueue.Output;
	};
	'com.atproto.temp.fetchLabels': {
		params: ComAtprotoTempFetchLabels.Params;
		output: ComAtprotoTempFetchLabels.Output;
	};
}

export declare interface Procedures {
	'com.atproto.admin.deleteAccount': {
		input: ComAtprotoAdminDeleteAccount.Input;
	};
	'com.atproto.admin.disableAccountInvites': {
		input: ComAtprotoAdminDisableAccountInvites.Input;
	};
	'com.atproto.admin.disableInviteCodes': {
		input: ComAtprotoAdminDisableInviteCodes.Input;
	};
	'com.atproto.admin.enableAccountInvites': {
		input: ComAtprotoAdminEnableAccountInvites.Input;
	};
	'com.atproto.admin.sendEmail': {
		input: ComAtprotoAdminSendEmail.Input;
		output: ComAtprotoAdminSendEmail.Output;
	};
	'com.atproto.admin.updateAccountEmail': {
		input: ComAtprotoAdminUpdateAccountEmail.Input;
	};
	'com.atproto.admin.updateAccountHandle': {
		input: ComAtprotoAdminUpdateAccountHandle.Input;
	};
	'com.atproto.admin.updateAccountPassword': {
		input: ComAtprotoAdminUpdateAccountPassword.Input;
	};
	'com.atproto.admin.updateSubjectStatus': {
		input: ComAtprotoAdminUpdateSubjectStatus.Input;
		output: ComAtprotoAdminUpdateSubjectStatus.Output;
	};
	'com.atproto.identity.requestPlcOperationSignature': {};
	'com.atproto.identity.signPlcOperation': {
		input: ComAtprotoIdentitySignPlcOperation.Input;
		output: ComAtprotoIdentitySignPlcOperation.Output;
	};
	'com.atproto.identity.submitPlcOperation': {
		input: ComAtprotoIdentitySubmitPlcOperation.Input;
	};
	'com.atproto.identity.updateHandle': {
		input: ComAtprotoIdentityUpdateHandle.Input;
	};
	'com.atproto.moderation.createReport': {
		input: ComAtprotoModerationCreateReport.Input;
		output: ComAtprotoModerationCreateReport.Output;
	};
	'com.atproto.repo.applyWrites': {
		input: ComAtprotoRepoApplyWrites.Input;
		output: ComAtprotoRepoApplyWrites.Output;
	};
	'com.atproto.repo.createRecord': {
		input: ComAtprotoRepoCreateRecord.Input;
		output: ComAtprotoRepoCreateRecord.Output;
	};
	'com.atproto.repo.deleteRecord': {
		input: ComAtprotoRepoDeleteRecord.Input;
		output: ComAtprotoRepoDeleteRecord.Output;
	};
	'com.atproto.repo.importRepo': {
		input: ComAtprotoRepoImportRepo.Input;
	};
	'com.atproto.repo.putRecord': {
		input: ComAtprotoRepoPutRecord.Input;
		output: ComAtprotoRepoPutRecord.Output;
	};
	'com.atproto.repo.uploadBlob': {
		input: ComAtprotoRepoUploadBlob.Input;
		output: ComAtprotoRepoUploadBlob.Output;
	};
	'com.atproto.server.activateAccount': {};
	'com.atproto.server.confirmEmail': {
		input: ComAtprotoServerConfirmEmail.Input;
	};
	'com.atproto.server.createAccount': {
		input: ComAtprotoServerCreateAccount.Input;
		output: ComAtprotoServerCreateAccount.Output;
	};
	'com.atproto.server.createAppPassword': {
		input: ComAtprotoServerCreateAppPassword.Input;
		output: ComAtprotoServerCreateAppPassword.Output;
	};
	'com.atproto.server.createInviteCode': {
		input: ComAtprotoServerCreateInviteCode.Input;
		output: ComAtprotoServerCreateInviteCode.Output;
	};
	'com.atproto.server.createInviteCodes': {
		input: ComAtprotoServerCreateInviteCodes.Input;
		output: ComAtprotoServerCreateInviteCodes.Output;
	};
	'com.atproto.server.createSession': {
		input: ComAtprotoServerCreateSession.Input;
		output: ComAtprotoServerCreateSession.Output;
	};
	'com.atproto.server.deactivateAccount': {
		input: ComAtprotoServerDeactivateAccount.Input;
	};
	'com.atproto.server.deleteAccount': {
		input: ComAtprotoServerDeleteAccount.Input;
	};
	'com.atproto.server.deleteSession': {};
	'com.atproto.server.refreshSession': {
		output: ComAtprotoServerRefreshSession.Output;
	};
	'com.atproto.server.requestAccountDelete': {};
	'com.atproto.server.requestEmailConfirmation': {};
	'com.atproto.server.requestEmailUpdate': {
		output: ComAtprotoServerRequestEmailUpdate.Output;
	};
	'com.atproto.server.requestPasswordReset': {
		input: ComAtprotoServerRequestPasswordReset.Input;
	};
	'com.atproto.server.reserveSigningKey': {
		input: ComAtprotoServerReserveSigningKey.Input;
		output: ComAtprotoServerReserveSigningKey.Output;
	};
	'com.atproto.server.resetPassword': {
		input: ComAtprotoServerResetPassword.Input;
	};
	'com.atproto.server.revokeAppPassword': {
		input: ComAtprotoServerRevokeAppPassword.Input;
	};
	'com.atproto.server.updateEmail': {
		input: ComAtprotoServerUpdateEmail.Input;
	};
	'com.atproto.sync.notifyOfUpdate': {
		input: ComAtprotoSyncNotifyOfUpdate.Input;
	};
	'com.atproto.sync.requestCrawl': {
		input: ComAtprotoSyncRequestCrawl.Input;
	};
	'com.atproto.temp.requestPhoneVerification': {
		input: ComAtprotoTempRequestPhoneVerification.Input;
	};
}
