import { simpleFetchHandler } from './fetch-handler.js';
import { XRPC, XRPCError } from './rpc.js';
import { getPdsEndpoint } from './utils/did.js';
import { decodeJwt } from './utils/jwt.js';
export class CredentialManager {
    #server;
    #refreshSessionPromise;
    #onExpired;
    #onRefresh;
    #onSessionUpdate;
    constructor({ service, onExpired, onRefresh, onSessionUpdate, fetch: _fetch = fetch, }) {
        this.serviceUrl = service;
        this.fetch = _fetch;
        this.#server = new XRPC({ handler: simpleFetchHandler({ service: service, fetch: _fetch }) });
        this.#onRefresh = onRefresh;
        this.#onExpired = onExpired;
        this.#onSessionUpdate = onSessionUpdate;
    }
    get dispatchUrl() {
        return this.session?.pdsUri ?? this.serviceUrl;
    }
    async handle(pathname, init) {
        await this.#refreshSessionPromise;
        const url = new URL(pathname, this.dispatchUrl);
        const headers = new Headers(init.headers);
        if (!this.session || headers.has('authorization')) {
            return (0, this.fetch)(url, init);
        }
        headers.set('authorization', `Bearer ${this.session.accessJwt}`);
        const initialResponse = await (0, this.fetch)(url, { ...init, headers });
        const isExpired = await isExpiredTokenResponse(initialResponse);
        if (!isExpired) {
            return initialResponse;
        }
        try {
            await this.#refreshSession();
        }
        catch {
            return initialResponse;
        }
        // Return initial response if:
        // - refreshSession returns expired
        // - Body stream has been consumed
        if (!this.session || init.body instanceof ReadableStream) {
            return initialResponse;
        }
        headers.set('authorization', `Bearer ${this.session.accessJwt}`);
        return await (0, this.fetch)(url, { ...init, headers });
    }
    #refreshSession() {
        return (this.#refreshSessionPromise ||= this.#refreshSessionInner().finally(() => (this.#refreshSessionPromise = undefined)));
    }
    async #refreshSessionInner() {
        const currentSession = this.session;
        if (!currentSession) {
            return;
        }
        try {
            const { data } = await this.#server.call('com.atproto.server.refreshSession', {
                headers: {
                    authorization: `Bearer ${currentSession.refreshJwt}`,
                },
            });
            this.#updateSession({ ...currentSession, ...data });
            this.#onRefresh?.(this.session);
        }
        catch (err) {
            if (err instanceof XRPCError) {
                const kind = err.kind;
                if (kind === 'ExpiredToken' || kind === 'InvalidToken') {
                    this.session = undefined;
                    this.#onExpired?.(currentSession);
                }
            }
        }
    }
    #updateSession(raw) {
        const didDoc = raw.didDoc;
        let pdsUri;
        if (didDoc) {
            pdsUri = getPdsEndpoint(didDoc);
        }
        const newSession = {
            accessJwt: raw.accessJwt,
            refreshJwt: raw.refreshJwt,
            handle: raw.handle,
            did: raw.did,
            pdsUri: pdsUri,
            email: raw.email,
            emailConfirmed: raw.emailConfirmed,
            emailAuthFactor: raw.emailConfirmed,
            active: raw.active ?? true,
            inactiveStatus: raw.status,
        };
        this.session = newSession;
        this.#onSessionUpdate?.(newSession);
        return newSession;
    }
    /**
     * Resume a saved session
     * @param session Session information, taken from `AtpAuth#session` after login
     */
    async resume(session) {
        const now = Date.now() / 1000 + 60 * 5;
        const refreshToken = decodeJwt(session.refreshJwt);
        if (now >= refreshToken.exp) {
            throw new XRPCError(401, { kind: 'InvalidToken' });
        }
        const accessToken = decodeJwt(session.accessJwt);
        this.session = session;
        if (now >= accessToken.exp) {
            await this.#refreshSession();
        }
        else {
            const promise = this.#server.get('com.atproto.server.getSession', {
                headers: {
                    authorization: `Bearer ${session.accessJwt}`,
                },
            });
            promise.then((response) => {
                const existing = this.session;
                const next = response.data;
                if (!existing) {
                    return;
                }
                this.#updateSession({ ...existing, ...next });
            });
        }
        if (!this.session) {
            throw new XRPCError(401, { kind: 'InvalidToken' });
        }
        return this.session;
    }
    /**
     * Perform a login operation
     * @param options Login options
     * @returns Session data that can be saved for later
     */
    async login(options) {
        // Reset the session
        this.session = undefined;
        const res = await this.#server.call('com.atproto.server.createSession', {
            data: {
                identifier: options.identifier,
                password: options.password,
                authFactorToken: options.code,
            },
        });
        return this.#updateSession(res.data);
    }
}
const isExpiredTokenResponse = async (response) => {
    if (response.status !== 400) {
        return false;
    }
    if (extractContentType(response.headers) !== 'application/json') {
        return false;
    }
    // {"error":"ExpiredToken","message":"Token has expired"}
    // {"error":"ExpiredToken","message":"Token is expired"}
    if (extractContentLength(response.headers) > 54 * 1.5) {
        return false;
    }
    try {
        const { error, message } = await response.clone().json();
        return error === 'ExpiredToken' && (typeof message === 'string' || message === undefined);
    }
    catch { }
    return false;
};
const extractContentType = (headers) => {
    return headers.get('content-type')?.split(';')[0]?.trim();
};
const extractContentLength = (headers) => {
    return Number(headers.get('content-length') ?? ';');
};
//# sourceMappingURL=credential-manager.js.map