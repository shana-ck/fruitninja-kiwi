import { buildFetchHandler } from './fetch-handler.js';
import { mergeHeaders } from './utils/http.js';
/** Error coming from the XRPC service */
export class XRPCError extends Error {
    constructor(status, { kind, description, headers, cause } = {}) {
        super(`${kind || 'UnspecifiedKind'} > ${description || `Unspecified error description`}`, { cause });
        this.name = 'XRPCError';
        this.status = status;
        this.kind = kind;
        this.description = description;
        this.headers = headers || {};
    }
}
export class XRPC {
    constructor({ handler, proxy }) {
        this.handle = buildFetchHandler(handler);
        this.proxy = proxy;
    }
    /**
     * Makes a query (GET) request
     * @param nsid Namespace ID of a query endpoint
     * @param options Options to include like parameters
     * @returns The response of the request
     */
    get(nsid, options) {
        return this.request({ type: 'get', nsid: nsid, ...options });
    }
    /**
     * Makes a procedure (POST) request
     * @param nsid Namespace ID of a procedure endpoint
     * @param options Options to include like input body or parameters
     * @returns The response of the request
     */
    call(nsid, options) {
        return this.request({ type: 'post', nsid: nsid, ...options });
    }
    /** Makes a request to the XRPC service */
    async request(options) {
        const data = options.data;
        const url = `/xrpc/${options.nsid}` + constructSearchParams(options.params);
        const isInputJson = isJsonValue(data);
        const response = await this.handle(url, {
            method: options.type,
            signal: options.signal,
            body: isInputJson ? JSON.stringify(data) : data,
            headers: mergeHeaders(options.headers, {
                'content-type': isInputJson ? 'application/json' : null,
                'atproto-proxy': constructProxyHeader(this.proxy),
            }),
        });
        const responseStatus = response.status;
        const responseHeaders = Object.fromEntries(response.headers);
        const responseType = responseHeaders['content-type'];
        let promise;
        let ret;
        if (responseType) {
            if (responseType.startsWith('application/json')) {
                promise = response.json();
            }
            else if (responseType.startsWith('text/')) {
                promise = response.text();
            }
        }
        try {
            ret = await (promise || response.arrayBuffer().then((buffer) => new Uint8Array(buffer)));
        }
        catch (err) {
            throw new XRPCError(2, {
                cause: err,
                kind: 'InvalidResponse',
                description: `Failed to parse response body`,
                headers: responseHeaders,
            });
        }
        if (responseStatus === 200) {
            return {
                data: ret,
                headers: responseHeaders,
            };
        }
        if (isErrorResponse(ret)) {
            throw new XRPCError(responseStatus, {
                kind: ret.error,
                description: ret.message,
                headers: responseHeaders,
            });
        }
        throw new XRPCError(responseStatus, { headers: responseHeaders });
    }
}
const constructProxyHeader = (proxy) => {
    if (proxy) {
        return `${proxy.service}#${proxy.type}`;
    }
    return null;
};
const constructSearchParams = (params) => {
    let searchParams;
    for (const key in params) {
        const value = params[key];
        if (value !== undefined) {
            searchParams ??= new URLSearchParams();
            if (Array.isArray(value)) {
                for (let idx = 0, len = value.length; idx < len; idx++) {
                    const val = value[idx];
                    searchParams.append(key, '' + val);
                }
            }
            else {
                searchParams.set(key, '' + value);
            }
        }
    }
    return searchParams ? `?` + searchParams.toString() : '';
};
const isJsonValue = (o) => {
    if (typeof o !== 'object' || o === null) {
        return false;
    }
    if ('toJSON' in o) {
        return true;
    }
    const proto = Object.getPrototypeOf(o);
    return proto === null || proto === Object.prototype;
};
const isErrorResponse = (value) => {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    const kindType = typeof value.error;
    const messageType = typeof value.message;
    return ((kindType === 'undefined' || kindType === 'string') &&
        (messageType === 'undefined' || messageType === 'string'));
};
export const clone = (rpc) => {
    return new XRPC({ handler: rpc.handle, proxy: rpc.proxy });
};
export const withProxy = (rpc, options) => {
    return new XRPC({ handler: rpc.handle, proxy: options });
};
//# sourceMappingURL=rpc.js.map