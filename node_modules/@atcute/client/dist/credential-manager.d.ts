import type { At } from './lexicons.js';
import { type FetchHandlerObject } from './fetch-handler.js';
/** Interface for the decoded access token, for convenience */
export interface AtpAccessJwt {
    /** Access token scope, app password returns a different scope. */
    scope: 'com.atproto.access' | 'com.atproto.appPass' | 'com.atproto.appPassPrivileged';
    /** Account DID */
    sub: At.DID;
    /** Expiration time */
    exp: number;
    /** Creation/issued time */
    iat: number;
}
/** Interface for the decoded refresh token, for convenience */
export interface AtpRefreshJwt {
    /** Refresh token scope */
    scope: 'com.atproto.refresh';
    /** ID of this refresh token */
    jti: string;
    /** Account DID */
    sub: At.DID;
    /** Intended audience of this refresh token, in DID */
    aud: At.DID;
    /** Expiration time */
    exp: number;
    /** Creation/issued time */
    iat: number;
}
/** Saved session data, this can be reused again for next time. */
export interface AtpSessionData {
    /** Refresh token */
    refreshJwt: string;
    /** Access token */
    accessJwt: string;
    /** Account handle */
    handle: string;
    /** Account DID */
    did: At.DID;
    /** PDS endpoint found in the DID document, this will be used as the service URI if provided */
    pdsUri?: string;
    /** Email address of the account, might not be available if on app password */
    email?: string;
    /** If the email address has been confirmed or not */
    emailConfirmed?: boolean;
    /** If the account has email-based two-factor authentication enabled */
    emailAuthFactor?: boolean;
    /** Whether the account is active (not deactivated, taken down, or suspended) */
    active: boolean;
    /** Possible reason for why the account is inactive */
    inactiveStatus?: string;
}
export interface CredentialManagerOptions {
    /** PDS server URL */
    service: string;
    /** Custom fetch function */
    fetch?: typeof globalThis.fetch;
    /** Function that gets called if the session turned out to have expired during an XRPC request */
    onExpired?: (session: AtpSessionData) => void;
    /** Function that gets called if the session has been refreshed during an XRPC request */
    onRefresh?: (session: AtpSessionData) => void;
    /** Function that gets called if the session object has been refreshed */
    onSessionUpdate?: (session: AtpSessionData) => void;
}
export declare class CredentialManager implements FetchHandlerObject {
    #private;
    readonly serviceUrl: string;
    fetch: typeof fetch;
    /** Current session state */
    session?: AtpSessionData;
    constructor({ service, onExpired, onRefresh, onSessionUpdate, fetch: _fetch, }: CredentialManagerOptions);
    get dispatchUrl(): string;
    handle(pathname: string, init: RequestInit): Promise<Response>;
    /**
     * Resume a saved session
     * @param session Session information, taken from `AtpAuth#session` after login
     */
    resume(session: AtpSessionData): Promise<AtpSessionData>;
    /**
     * Perform a login operation
     * @param options Login options
     * @returns Session data that can be saved for later
     */
    login(options: AuthLoginOptions): Promise<AtpSessionData>;
}
/** Login options */
export interface AuthLoginOptions {
    /** What account to login as, this could be domain handle, DID, or email address */
    identifier: string;
    /** Account password */
    password: string;
    /** Two-factor authentication code */
    code?: string;
}
