import type { At, Procedures, Queries } from './lexicons.js';
import { type FetchHandler, type FetchHandlerObject } from './fetch-handler.js';
export type HeadersObject = Record<string, string>;
/** Response from XRPC service */
export interface XRPCResponse<T = any> {
    data: T;
    headers: HeadersObject;
}
/** Options for constructing an XRPC error */
export interface XRPCErrorOptions {
    kind?: string;
    description?: string;
    headers?: HeadersObject;
    cause?: unknown;
}
/** Error coming from the XRPC service */
export declare class XRPCError extends Error {
    name: string;
    /** Response status */
    status: number;
    /** Response headers */
    headers: HeadersObject;
    /** Error kind */
    kind?: string;
    /** Error description */
    description?: string;
    constructor(status: number, { kind, description, headers, cause }?: XRPCErrorOptions);
}
/** Service proxy options */
export interface XRPCProxyOptions {
    type: 'atproto_pds' | 'atproto_labeler' | 'bsky_fg' | 'bsky_notif' | ({} & string);
    service: At.DID;
}
/** Options for constructing an XRPC */
export interface XRPCOptions {
    handler: FetchHandler | FetchHandlerObject;
    proxy?: XRPCProxyOptions;
}
/** XRPC request options */
export interface XRPCRequestOptions {
    type: 'get' | 'post';
    nsid: string;
    headers?: HeadersInit;
    params?: Record<string, unknown>;
    data?: FormData | Blob | ArrayBufferView | Record<string, unknown>;
    signal?: AbortSignal;
}
/** XRPC response */
export interface XRPCResponse<T = any> {
    data: T;
    headers: HeadersObject;
}
/** Base options for the query/procedure request */
interface BaseRPCOptions {
    /** Request headers to make */
    headers?: HeadersInit;
    /** Signal for aborting the request */
    signal?: AbortSignal;
}
/** Options for the query/procedure request */
export type RPCOptions<T> = BaseRPCOptions & (T extends {
    params: any;
} ? {
    params: T['params'];
} : {}) & (T extends {
    input: any;
} ? {
    data: T['input'];
} : {});
type OutputOf<T> = T extends {
    output: any;
} ? T['output'] : never;
export declare class XRPC {
    handle: FetchHandler;
    proxy: XRPCProxyOptions | undefined;
    constructor({ handler, proxy }: XRPCOptions);
    /**
     * Makes a query (GET) request
     * @param nsid Namespace ID of a query endpoint
     * @param options Options to include like parameters
     * @returns The response of the request
     */
    get<K extends keyof Queries>(nsid: K, options: RPCOptions<Queries[K]>): Promise<XRPCResponse<OutputOf<Queries[K]>>>;
    /**
     * Makes a procedure (POST) request
     * @param nsid Namespace ID of a procedure endpoint
     * @param options Options to include like input body or parameters
     * @returns The response of the request
     */
    call<K extends keyof Procedures>(nsid: K, options: RPCOptions<Procedures[K]>): Promise<XRPCResponse<OutputOf<Procedures[K]>>>;
    /** Makes a request to the XRPC service */
    request(options: XRPCRequestOptions): Promise<XRPCResponse>;
}
export declare const clone: (rpc: XRPC) => XRPC;
export declare const withProxy: (rpc: XRPC, options: XRPCProxyOptions) => XRPC;
export {};
